NOTES ABOUT ETERMSVAR ABSTRACT DOMAIN
=====================================

The etermsvar domain enhances the eterms domain of regular types by adding
a new native type: "vr", which corresponds to variables. This is different
to the combination of the eterms domain (which gives information only about
ground terms) and shfr (which gives information about freeness of variables).
For example, a "list of variables" can be represented in etermsvar as
list(vr), but cannot be represented using eterms+shfr. Conversely, the shfr
is able to represent "X and Y are alias to the same variable", whereas
etermsvar cannot.

The main user of etermsvar right now is the "res_plai" abstract domain,
which analyzes sized types and resources. The combined types+freeness
information that etermsvar gives is used for determining which parts of the
head variables should be considered as input and which as output. And this
etermsvar domain is the only one that allows to tell that the head of a list
is a variable, while the tail is ground.

Basically, the etermsvar domain adds a new type to the domain, "vr", which
is not comparable with any other type but with "term" (which is the top of
the lattice) and "$bottom". Most of the operations are then the same as in
etermsvar, where the new element is added to the lattice.

This means that in general the LUB of a "list of numbers" and "vr" will be
be a new type which is the disjunction of those two. In most cases this 
behavior inherited from the eterms domain and the typeslib is correct.
However, in a couple of places changes are needed and this is the objective
of the etermsvar domain.

For example, let's consider the predicates:

  f(X,Y) :- g(Y).
  g([]).

and analyze f with the call substitution num(X), vr(Y). At some point we will
analyze g, for which we would get an assertion vr(Y) => list(Y). If in the
extend step we perform the same as in etermsvar, we find a puzzling result.
So the correct solution is to create, for those cases, a special way of inter-
secting types which takes into account that intersect(vr,X) = X for every X.
